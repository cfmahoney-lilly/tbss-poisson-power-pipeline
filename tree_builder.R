#' Build Hierarchical Tree from Code List
#'
#' Creates a parent-child relationship table from a list of hierarchical codes
#' by recursively extracting parent codes until a minimum level is reached.
#' Parent codes are generated by removing the last character iteratively.
#' Optimized to handle input data containing a mix of both parent and child codes.
#' Output format is suitable for use with the tbss package (Russo & Wang 2024).
#'
#' @param code_list Character vector of hierarchical codes (e.g., ICD-10-CM codes). 
#'   Each code should be a string where parent relationships are determined by 
#'   truncating from the right. Can contain a mix of parent and child codes. 
#'   Codes must contain only alphanumeric characters (A-Z, a-z, 0-9). Periods 
#'   and other special characters are not permitted.
#' @param min_level Integer specifying the minimum code length to process.
#'   Codes will be truncated until they reach the specified length. Must be a 
#'   positive integer.
#' @param deduplicate_input Logical indicating whether to remove duplicate codes
#'   from input before processing. Default is TRUE. Set to FALSE if input is 
#'   already unique for better performance.
#' @param strict_validation Logical indicating whether to stop on invalid characters
#'   (TRUE, default) or issue a warning and remove invalid codes (FALSE).
#'
#' @return A data frame with two columns:
#'   \describe{
#'     \item{child}{Character vector of child codes}
#'     \item{parent}{Character vector of parent codes}
#'   }
#'   Each row represents a parent-child relationship. Duplicate relationships
#'   are removed.
#'
#' @details
#' For each code in \code{code_list}, the function generates all parent-child
#' pairs by successively removing the last character until the code reaches
#' \code{min_level} characters. For example, if \code{min_level = 3} and a
#' code is "A01BC", the function creates pairs: ("A01BC", "A01B"), ("A01B", "A01").
#'
#' The function is optimized for cases where the input contains both parent and
#' child codes (e.g., "E11", "E116", "E1165"). It:
#' \itemize{
#'   \item Deduplicates input codes to avoid redundant processing
#'   \item Processes codes from longest to shortest to maximize efficiency
#'   \item Skips generation of relationships that already exist from longer codes
#'   \item Validates that codes contain only alphanumeric characters
#' }
#'
#' Codes shorter than or equal to \code{min_level} are skipped as they have no
#' parents to extract.
#'
#' @examples
#' # ICD-10 codes with mixed parent-child relationships
#' # Note: periods removed from ICD-10 codes (E11.65 becomes E1165)
#' codes <- c("E11651", "E11652", "E116", "E11", "E119", "I10", "I101")
#' tree_builder(codes, min_level = 3)
#'
#' # Handle invalid characters with warning instead of error
#' messy_codes <- c("E1165", "E11-9", "I10.1")
#' tree_builder(messy_codes, min_level = 3, strict_validation = FALSE)
#'
#' @export
tree_builder <- function(code_list, min_level, deduplicate_input = TRUE, 
                         strict_validation = TRUE) {
  
  # Input validation
  
  # Check code_list is provided
  if (missing(code_list)) {
    stop("Argument 'code_list' is missing with no default.", call. = FALSE)
  }
  
  # Check min_level is provided
  if (missing(min_level)) {
    stop("Argument 'min_level' is missing with no default.", call. = FALSE)
  }
  
  # Check code_list is a character vector
  if (!is.character(code_list)) {
    stop("'code_list' must be a character vector.", call. = FALSE)
  }
  
  # Check code_list is not empty
  if (length(code_list) == 0) {
    stop("'code_list' cannot be empty.", call. = FALSE)
  }
  
  # Check for NA values in code_list
  if (any(is.na(code_list))) {
    warning("'code_list' contains NA values which will be ignored.", call. = FALSE)
    code_list <- code_list[!is.na(code_list)]
  }
  
  # Check for empty strings
  if (any(code_list == "")) {
    warning("'code_list' contains empty strings which will be ignored.", call. = FALSE)
    code_list <- code_list[code_list != ""]
  }
  
  # Check if code_list is empty after cleaning
  if (length(code_list) == 0) {
    stop("'code_list' is empty after removing NA and empty string values.", 
         call. = FALSE)
  }
  
  # Check min_level is numeric
  if (!is.numeric(min_level)) {
    stop("'min_level' must be numeric.", call. = FALSE)
  }
  
  # Check min_level is a single value
  if (length(min_level) != 1) {
    stop("'min_level' must be a single value.", call. = FALSE)
  }
  
  # Check min_level is positive
  if (min_level < 1) {
    stop("'min_level' must be a positive integer (>= 1).", call. = FALSE)
  }
  
  # Convert min_level to integer
  min_level <- as.integer(min_level)
  
  # Check deduplicate_input is logical
  if (!is.logical(deduplicate_input) || length(deduplicate_input) != 1) {
    stop("'deduplicate_input' must be a single logical value (TRUE or FALSE).", 
         call. = FALSE)
  }
  
  # Check strict_validation is logical
  if (!is.logical(strict_validation) || length(strict_validation) != 1) {
    stop("'strict_validation' must be a single logical value (TRUE or FALSE).", 
         call. = FALSE)
  }
  
  # Only allow alphanumeric characters (no periods or special characters)
  valid_pattern <- "^[A-Za-z0-9]+$"
  allowed_chars_msg <- "alphanumeric characters (A-Z, a-z, 0-9) only"
  
  # Check for invalid characters
  invalid_codes <- !grepl(valid_pattern, code_list)
  
  if (any(invalid_codes)) {
    invalid_examples <- code_list[invalid_codes]
    n_invalid <- sum(invalid_codes)
    
    # Show up to 5 examples of invalid codes
    example_codes <- head(invalid_examples, 5)
    example_msg <- paste0("  '", example_codes, "'", collapse = "\n")
    
    error_msg <- sprintf(
      paste0(
        "'code_list' contains %d code(s) with invalid characters.\n",
        "Codes must contain only %s.\n",
        "Invalid code examples:\n%s%s"
      ),
      n_invalid,
      allowed_chars_msg,
      example_msg,
      if (n_invalid > 5) sprintf("\n  ... and %d more", n_invalid - 5) else ""
    )
    
    if (strict_validation) {
      stop(error_msg, call. = FALSE)
    } else {
      warning(
        paste0(error_msg, "\nRemoving invalid codes and continuing."),
        call. = FALSE
      )
      code_list <- code_list[!invalid_codes]
    }
  }
  
  # Check if code_list is empty after validation
  if (length(code_list) == 0) {
    stop(
      "'code_list' is empty after removing invalid codes.", 
      call. = FALSE
    )
  }
  
  # Check if any codes are long enough to generate relationships
  max_code_length <- max(nchar(code_list))
  if (max_code_length <= min_level) {
    warning(
      sprintf(
        "All codes have length <= min_level (%d). Returning empty data frame.",
        min_level
      ),
      call. = FALSE
    )
    return(data.frame(child = character(0), parent = character(0), 
                      stringsAsFactors = FALSE))
  }
  
  # Deduplicate input codes if requested
  if (deduplicate_input) {
    code_list <- unique(code_list)
  }
  
  # Sort codes by length, longest/most specific first
  code_lengths <- nchar(code_list)
  code_list <- code_list[order(code_lengths, decreasing = TRUE)]
  
  # Hash set to track parent-child relationships 
  seen_pairs <- new.env(hash = TRUE, parent = emptyenv())
  
  children <- character()
  parents <- character()
  
  for (code in code_list) {
    code_length <- nchar(code)
    n_pairs <- max(0, code_length - min_level)
    
    if (n_pairs > 0) {
      # All potential child and parent codes
      potential_children <- substring(code, 1, (min_level + 1):code_length)
      potential_parents <- substring(code, 1, min_level:(code_length - 1))
      
      # Add only previously unseen pairs 
      for (i in seq_along(potential_children)) {
        pair_key <- paste(potential_children[i], potential_parents[i], sep = "|")
        
        if (!exists(pair_key, envir = seen_pairs)) {
          children <- c(children, potential_children[i])
          parents <- c(parents, potential_parents[i])
          
          # Mark this pair as seen
          assign(pair_key, TRUE, envir = seen_pairs)
        }
      }
    }
  }
  
  # Return parent-child pairs (already unique due to seen_pairs tracking)
  data.frame(
    child = children, 
    parent = parents, 
    stringsAsFactors = FALSE
  )
}

